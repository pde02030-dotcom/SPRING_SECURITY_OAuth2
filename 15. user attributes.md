# OAuth2 / OpenID Connect의 **User Attributes** 🧾🔐

(= “로그인한 사용자가 누구인지”를 표현하는 **클레임/속성 묶음**)

OAuth2와 OpenID Connect(OIDC)에서 “user attributes”는 한마디로 **인증/인가 이후 서버가 클라이언트에게 전달하는 ‘사용자 정보’** 입니다.
다만 OAuth2와 OIDC는 성격이 달라서, **어디에서 / 어떤 형태로 / 어떤 의미로** 사용자 정보가 오느냐가 달라집니다. 🧠

---

## 1) 먼저 큰 그림: OAuth2 vs OIDC 차이 🧩

### ✅ OAuth2에서의 “user attributes”

* OAuth2는 원래 **인가(Authorization)** 프레임워크입니다.
* “사용자 정보”는 **표준의 핵심이 아니라** 보통 각 Provider가 제공하는 **Resource API(UserInfo API 같은 것)** 에서 가져옵니다.
* 즉 OAuth2만 쓰면:

  * “이 토큰이 누구 사용자 건지”는 **서버가 제공하는 별도 API**에 의존하는 경우가 많습니다. 🌐

### ✅ OIDC에서의 “user attributes”

* OIDC는 OAuth2 위에 올라탄 **인증(Authentication)** 레이어입니다.
* 그래서 “사용자 정보(Claims)”가 **표준으로 정의**되어 있고,

  * **ID Token(JWT)** 안에도 들어올 수 있고,
  * **UserInfo Endpoint**에서도 받을 수 있습니다. 🪪

> 정리하면:
> OAuth2의 user attributes는 “보통 Provider의 사용자 API에서 가져오는 값”
> OIDC의 user attributes는 “표준 Claim(속성)으로서 ID Token / UserInfo에서 제공되는 값”

---

## 2) User Attributes는 어디에서 오나? (3대 공급원) 🏭

### ① **ID Token (OIDC)** 🪪✅

* 로그인(Authorization Code Flow 등) 후 **토큰 교환**을 하면,
* 응답으로 `id_token`이 올 수 있습니다.
* `id_token`은 보통 JWT이며, 내부에 사용자 클레임이 있습니다.

예:

```json
{
  "iss": "https://issuer.example.com",
  "sub": "248289761001",
  "aud": "client-id",
  "exp": 1710000000,
  "iat": 1709996400,
  "email": "user@example.com",
  "name": "Kim",
  "picture": "https://..."
}
```

📌 특징

* **로그인(인증) 결과물**에 가까움
* 최소한의 식별정보(특히 `sub`)는 거의 항상 존재
* “이 사용자가 누구인지”를 **서명 검증으로 신뢰** 가능 🔏

---

### ② **UserInfo Endpoint (OIDC / OAuth2에서 흔히 사용)** 👤🌐

* Access Token으로 호출하는 API
* “더 풍부한 사용자 프로필”을 가져오는 용도

예:

* `GET /userinfo`
* `Authorization: Bearer {access_token}`

📌 특징

* **가장 풍부한 속성**을 받을 수 있는 경우가 많음
* Scope에 따라 반환 필드가 달라짐 (`profile`, `email` 등) 🎯
* Access Token의 권한/범위에 의해 제한됨

---

### ③ **Access Token 자체에 포함된 Claims (JWT Access Token일 때)** 🎫🧩

* 일부 시스템(특히 사내 Authorization Server, Keycloak 등)은
* Access Token을 JWT로 발급하고 **클레임에 사용자 속성을 넣기도** 합니다.

📌 특징

* Resource Server가 UserInfo 호출 없이도 사용자 정보를 알 수 있어 성능상 유리 ⚡
* 하지만 토큰이 커지고(네트워크 비용) 노출 리스크가 커질 수 있음 🧨
* 일반적으로 “최소 권한 + 최소 정보”가 권장됨

---

## 3) “Attribute / Claim / Principal” 용어 정리 📚

* **Attribute**: 구현/프레임워크 관점에서 “사용자 속성” (Map 형태로 흔함)
* **Claim**: OIDC/JWT 표준 용어로 “토큰에 담긴 속성 키-값”
* **Principal**: Spring Security에서 “현재 인증된 주체(사용자)” 객체
* **Authorities/Roles**: 권한(인가)용 정보 (attributes와는 용도가 다름)

---

## 4) 표준 User Attributes(Claims) 예시 모음 🧾✨

OIDC 표준에는 대표적인 claims가 있습니다. (Provider마다 일부 다르게 제공)

### 🧍 식별 관련

* `sub`: **사용자 고유 식별자**(Issuer 내에서 유니크) ⭐ 핵심
* `preferred_username`: 사용자명
* `name`, `given_name`, `family_name`
* `nickname`

### 📧 연락 관련

* `email`, `email_verified`
* `phone_number`, `phone_number_verified`

### 🖼️ 프로필

* `picture`
* `profile`
* `website`

### 🌍 위치/로케일

* `locale`
* `zoneinfo`
* `address` (복합 객체)

> ✅ 실무 팁
> 사용자 계정의 “PK”로는 **email보다 `sub`가 훨씬 안전**합니다.
> (email은 변경될 수 있고, Provider 정책에 따라 미제공/마스킹 가능) 🔐

---

## 5) Scope와 User Attributes 관계 🎯

사용자 속성은 보통 **Scope(동의 범위)**에 의해 결정됩니다.

* `openid` ✅ : OIDC 로그인임을 의미 (ID Token 발급의 전제)
* `profile` 👤 : 이름/사진/닉네임 등
* `email` 📧 : 이메일 관련
* `address` 🏠 : 주소
* `phone` 📱 : 전화번호

즉,

* 스코프를 적게 요청하면 → attributes도 최소만 옴
* 스코프를 많이 요청하면 → 더 많은 개인정보가 옴 (보안/동의 부담 증가) ⚖️

---

## 6) Spring Security 관점에서의 user attributes 🧩☕

(여기서 “attributes”가 정말 많이 등장합니다)

### ✅ OAuth2Login (소셜 로그인)에서는 보통 이렇게 연결됩니다

* 토큰 교환 후
* (OIDC면) `OidcUserService` / (OAuth2면) `DefaultOAuth2UserService`
* UserInfo Endpoint 호출
* 응답(JSON)을 **Map<String, Object> attributes**로 저장

결과적으로:

* `OAuth2User#getAttributes()`
* `OidcUser#getClaims()` (ID Token/UserInfo 기반)

📌 그리고 흔히 마주치는 현실 문제:

* Provider마다 키 이름이 다름 😵

  * Google: `sub`, `email`, `name`…
  * GitHub: `id`, `login`, `avatar_url`…
  * Naver/Kakao: 중첩 구조가 많음 (`response` 아래에 있음 등)

➡️ 그래서 보통 “표준화/매핑 레이어”를 직접 둡니다. 🔧

---

## 7) 실무에서 가장 중요한 이슈 7가지 🚧✅

### 1) `sub`를 내부 사용자 식별자로 쓰는 게 정석 🧷

* Provider가 바뀌거나 이메일이 바뀌어도 흔들리지 않는 키

### 2) Provider별 attribute 키가 다르니 “정규화 DTO”가 필요 🧱

* `UserProfile { provider, providerUserId(sub), email, name, picture }` 같은 형태로 통일

### 3) UserInfo 호출은 “항상 가능”이 아니다 🌐

* Provider/설정에 따라 UserInfo를 안 주거나,
* ID Token에만 주는 경우도 있음

### 4) 토큰/클레임에는 최소한만 넣는 게 원칙 🔏

* Access Token에 개인정보를 과도하게 넣으면 위험

### 5) “권한(Role)”은 attributes와 분리해서 설계 🛡️

* attributes는 “프로필”
* authorities는 “인가 판단”

### 6) 스코프 요청은 최소로 🎯

* 개인정보 동의/보안/심사 이슈가 커짐

### 7) 중첩 JSON 구조 대응 필요 🧬

* `kakao_account.profile.nickname` 같은 구조를 안전하게 파싱/매핑

---

## 8) 자주 헷갈리는 질문들 Q&A 🙋‍♂️🙋‍♀️

### Q1. “User attributes”는 Access Token이랑 같은 거예요?

👉 아니요.
Access Token은 “리소스 접근 권한 증표”이고,
User attributes는 “사용자 정보(클레임/프로필 데이터)”입니다. 🎫 vs 👤

### Q2. ID Token이 있는데 UserInfo도 호출해야 하나요?

👉 케이스 바이 케이스입니다.

* ID Token에 필요한 정보가 충분하면 굳이 안 해도 됨 ✅
* 더 많은 프로필이 필요하면 UserInfo 호출 👤
* 최신 정보(예: 프로필 이미지 변경)를 원하면 UserInfo가 유리 🔄

### Q3. 이메일을 유저 PK로 쓰면 안 되나요?

👉 가능은 하지만 위험합니다.
이메일은 바뀔 수 있고 제공되지 않을 수도 있어요.
가능하면 `sub` 기반 + 이메일은 “속성”으로 취급하는 게 안전합니다. 🔐

---

## 9) 한 줄 요약 🧾✨

* **OIDC의 user attributes = 표준 Claims** (ID Token/UserInfo로 제공)
* **OAuth2의 user attributes = 보통 Provider의 사용자 API 응답**
* 실무 핵심은 **(1) sub 중심 식별, (2) Provider별 매핑/정규화, (3) 최소 스코프/최소 정보**입니다. ✅

---

### 참고 사항
* ✅ Spring Security에서 `OAuth2User` / `OidcUser` 내부 구조(어디에 무엇이 저장되는지)
* ✅ Provider별 attributes 매핑 전략(구글/깃허브/네이버/카카오 예시)
* ✅ “우리 서비스 User 엔티티” 설계: `(provider, providerUserId=sub)` 유니크 키 패턴
* ✅ JWT Access Token에 claims 넣을 때의 장단점 + 보안 체크리스트
