## AuthorizationRequest 생성

이 단계는 사용자가 '구글 로그인' 버튼을 누른 직후, 우리 서버가 사용자를 구글(인가 서버)의 로그인 페이지로 보내기 위해 **"공식 요청서(소개서)"를 조립하는 과정**입니다.

`response_type`이나 `state` 값들이 바로 이 "요청서" 안에 담기는 핵심 내용물입니다. 

---

### **1. 누가, 언제 이 요청서를 만들까?**

* **언제 (Trigger):** 사용자가 브라우저에서 `/oauth2/authorization/{registrationId}` (예: `/oauth2/authorization/google`) 링크를 클릭했을 때 시작됩니다.
* **누가 (Actor):** `OAuth2AuthorizationRequestRedirectFilter`라는 필터가 이 요청을 가로챈 뒤, 내부의 **`OAuth2AuthorizationRequestResolver`** (디폴트 구현체: `DefaultOAuth2AuthorizationRequestResolver`)에게 "요청서 좀 만들어줘!"라고 지시합니다.

### **2. AuthorizationRequest (요청서) 내부에는 무엇이 담길까?**

Resolver는 우리가 `application.yml`에 적어둔 설정(`ClientRegistration`)을 바탕으로 다음과 같은 파라미터들을 조합해 객체를 완성합니다.

* **`client_id`**: "우리 서비스의 고유 식별자입니다." (누가 요청했는지)
* **`response_type`**: `code` "아까 배운 것처럼, 인증 끝나면 Access Token 대신 일단 '인가 코드(교환권)'로 주세요."
* **`redirect_uri`**: "로그인 다 끝나면 이 주소로 사용자를 돌려보내 주세요."
* **`scope`**: "우리는 이 사용자의 '이름'과 '이메일' 정보만 접근하겠습니다."
* **`state`**: "CSRF 공격을 막기 위해 제가 발행한 난수표입니다. 이따가 그대로 돌려주셔야 합니다." (방금 전 **저장소(Repository)** 파트에서 우리가 보관해둔 바로 그 값입니다!)
* **`nonce`**: (만약 OIDC 로그인인 경우) ID Token의 위변조를 막기 위한 추가 난수 값입니다.

### **3. 만들어진 요청서는 어떻게 쓰일까?**

이 객체가 완성되면 두 가지 작업이 동시에 일어납니다.

1. **저장**: 방금 전 설명해 드린 `AuthorizationRequestRepository`(세션 또는 쿠키)에 이 객체를 소중하게 **보관**합니다. (나중에 돌아왔을 때 `state`를 검증해야 하니까요)
2. **리다이렉트**: 이 객체의 정보들을 URL 쿼리 파라미터로 쭉 이어 붙여서(예: `https://accounts.google.com/o/oauth2/v2/auth?client_id=...&response_type=code...`), 사용자 브라우저에게 **"이 주소(구글 로그인 페이지)로 이동해!"(HTTP 302 Redirect)** 라고 응답을 보냅니다.


---

## AuthorizationRequest 저장

이 부분은 OAuth2 로그인 과정에서 **보안(CSRF 공격 방어)** 과 **상태 유지**를 위해 필수적으로 거쳐야 하는 아주 중요한 길목입니다.

---

### **1. 도대체 왜 `AuthorizationRequest`를 저장해야 할까요? (필요성)**

OAuth2 로그인은 우리 서버를 잠시 떠나 외부 인가 서버(구글, 카카오 등)를 다녀오는 과정입니다.

사용자를 구글 로그인 페이지로 리다이렉트 시키기 직전, 우리 서버는 **"내가 이 사용자에게 어떤 설정(client_id, redirect_uri, scope 등)으로 로그인을 요청했었지?"** 하는 **원본 요청 객체(`OAuth2AuthorizationRequest`)**를 어딘가에 기록해 두어야 합니다.

가장 핵심적인 이유는 **`state` 파라미터 검증** 때문입니다.

* 서버는 구글로 사용자를 보낼 때 랜덤한 난수열인 `state` 값을 만들어 함께 보냅니다.
* 사용자가 로그인을 마치고 우리 서버(`redirect_uri`)로 돌아올 때, 구글은 그 `state` 값을 그대로 돌려줍니다.
* 이때 서버는 **자신이 저장해둔 원본 `state` 값**과 **구글이 돌려준 `state` 값**을 비교하여, 이 요청이 해커가 위조한 비정상적인 요청(CSRF 공격)이 아닌지 검증해야 합니다. 이를 위해 원본 요청을 반드시 "저장"해두어야 하는 것입니다.

---

### **2. 기본값: `HttpSessionOAuth2AuthorizationRequestRepository**`

스프링 시큐리티가 아무런 설정 없이 기본적으로 사용하는 방식입니다.

* **동작 방식:** 생성된 `AuthorizationRequest` 객체를 서버의 **HTTP 세션(Session) 메모리**에 저장합니다.
* **장점:** 설정할 것이 전혀 없고, 타임리프(Thymeleaf)나 JSP 등을 사용하는 전통적인 서버 사이드 렌더링(SSR) 환경에서는 완벽하게 동작합니다.
* **단점 / 한계:** 백엔드 서버가 여러 대이거나, 세션을 사용하지 않도록 설계된 최신 REST API 서버에서는 문제가 발생할 수 있습니다.

---

### **3. 대안: 쿠키 기반 Repository (Custom 구현)**

이 대안 방식은 **React, Vue 등의 SPA 프론트엔드와 JWT(JSON Web Token)를 사용하는 Stateless(무상태) 백엔드 아키텍처**에서 매우 중요하게 다뤄지는 실무 스킬입니다.

* **문제 제기:** JWT를 사용하는 REST API 서버는 기본적으로 세션을 유지하지 않습니다(Stateless). 그런데 OAuth2 로그인을 하려고 세션을 열어버리면 아키텍처의 일관성이 깨집니다.
* **해결책 (쿠키 방식):** 서버 메모리에 저장하는 대신, `AuthorizationRequest` 객체를 직렬화(Serialize)하고 Base64로 인코딩하여 **사용자 브라우저의 임시 쿠키(Cookie)에 저장**해 보냅니다.
* **동작 방식:**
1. 사용자가 구글로 갈 때 브라우저 쿠키에 요청 정보를 구워 넣습니다.
2. 사용자가 인증 코드를 들고 서버로 돌아올 때, 브라우저가 알아서 이 쿠키를 서버로 다시 가져옵니다.
3. 서버는 쿠키의 내용을 해독해 `state` 값을 검증하고, 검증이 끝나면 보안을 위해 해당 쿠키를 즉시 삭제합니다.


* **특징:** 스프링 시큐리티에서 기본 클래스로 제공하지 않기 때문에, 개발자가 직접 `OAuth2AuthorizationRequestRepository` 인터페이스를 구현하는 클래스를 만들어 Bean으로 등록해야 합니다.

```
import jakarta.servlet.http.Cookie;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import org.springframework.util.SerializationUtils;
import java.util.Base64;

public class CookieUtils {

    // 쿠키 가져오기
    public static Cookie getCookie(HttpServletRequest request, String name) {
        Cookie[] cookies = request.getCookies();
        if (cookies != null && cookies.length > 0) {
            for (Cookie cookie : cookies) {
                if (cookie.getName().equals(name)) {
                    return cookie;
                }
            }
        }
        return null;
    }

    // 쿠키 생성 및 응답에 추가
    public static void addCookie(HttpServletResponse response, String name, String value, int maxAge) {
        Cookie cookie = new Cookie(name, value);
        cookie.setPath("/");
        cookie.setHttpOnly(true); // XSS 공격 방지를 위해 HttpOnly 설정
        cookie.setMaxAge(maxAge);
        response.addCookie(cookie);
    }

    // 쿠키 삭제
    public static void deleteCookie(HttpServletRequest request, HttpServletResponse response, String name) {
        Cookie[] cookies = request.getCookies();
        if (cookies != null && cookies.length > 0) {
            for (Cookie cookie : cookies) {
                if (cookie.getName().equals(name)) {
                    cookie.setValue("");
                    cookie.setPath("/");
                    cookie.setMaxAge(0);
                    response.addCookie(cookie);
                }
            }
        }
    }

    // 객체를 Base64 문자열로 직렬화
    public static String serialize(Object object) {
        return Base64.getUrlEncoder()
                .encodeToString(SerializationUtils.serialize(object));
    }

    // Base64 문자열을 객체로 역직렬화
    public static <T> T deserialize(Cookie cookie, Class<T> cls) {
        return cls.cast(SerializationUtils.deserialize(
                Base64.getUrlDecoder().decode(cookie.getValue())));
    }
}

```

```
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import org.springframework.security.oauth2.client.web.AuthorizationRequestRepository;
import org.springframework.security.oauth2.core.endpoint.OAuth2AuthorizationRequest;
import org.springframework.stereotype.Component;

@Component
public class HttpCookieOAuth2AuthorizationRequestRepository implements AuthorizationRequestRepository<OAuth2AuthorizationRequest> {

    public static final String OAUTH2_AUTHORIZATION_REQUEST_COOKIE_NAME = "oauth2_auth_request";
    public static final String REDIRECT_URI_PARAM_COOKIE_NAME = "redirect_uri";
    private static final int cookieExpireSeconds = 180; // 3분 (로그인 과정을 마치는 데 충분한 시간)

    // 1. 쿠키에서 인가 요청 정보 가져오기 (인가 서버에서 돌아왔을 때 사용)
    @Override
    public OAuth2AuthorizationRequest loadAuthorizationRequest(HttpServletRequest request) {
        Cookie cookie = CookieUtils.getCookie(request, OAUTH2_AUTHORIZATION_REQUEST_COOKIE_NAME);
        if (cookie != null) {
            return CookieUtils.deserialize(cookie, OAuth2AuthorizationRequest.class);
        }
        return null;
    }

    // 2. 인가 요청 정보를 쿠키에 저장 (인가 서버로 리다이렉트 하기 직전에 호출됨)
    @Override
    public void saveAuthorizationRequest(OAuth2AuthorizationRequest authorizationRequest, HttpServletRequest request, HttpServletResponse response) {
        if (authorizationRequest == null) {
            removeAuthorizationRequestCookies(request, response);
            return;
        }

        // 인가 요청 객체를 직렬화하여 쿠키에 저장
        CookieUtils.addCookie(response, OAUTH2_AUTHORIZATION_REQUEST_COOKIE_NAME, CookieUtils.serialize(authorizationRequest), cookieExpireSeconds);
        
        // (선택) 프론트엔드에서 파라미터로 넘긴 최종 리다이렉트 목적지가 있다면 쿠키에 함께 저장
        String redirectUriAfterLogin = request.getParameter(REDIRECT_URI_PARAM_COOKIE_NAME);
        if (redirectUriAfterLogin != null && !redirectUriAfterLogin.isBlank()) {
            CookieUtils.addCookie(response, REDIRECT_URI_PARAM_COOKIE_NAME, redirectUriAfterLogin, cookieExpireSeconds);
        }
    }

    // 3. (구버전 호환) 요청 정보를 삭제하면서 반환
    @Override
    public OAuth2AuthorizationRequest removeAuthorizationRequest(HttpServletRequest request, HttpServletResponse response) {
        return this.loadAuthorizationRequest(request);
    }

    // 4. 인증 완료 후 찌꺼기 쿠키 삭제 (Custom)
    public void removeAuthorizationRequestCookies(HttpServletRequest request, HttpServletResponse response) {
        CookieUtils.deleteCookie(request, response, OAUTH2_AUTHORIZATION_REQUEST_COOKIE_NAME);
        CookieUtils.deleteCookie(request, response, REDIRECT_URI_PARAM_COOKIE_NAME);
    }
}

```

```
import lombok.RequiredArgsConstructor;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.web.SecurityFilterChain;

@Configuration
@RequiredArgsConstructor
public class SecurityConfig {

    // 우리가 만든 커스텀 Repository 주입
    private final HttpCookieOAuth2AuthorizationRequestRepository cookieAuthorizationRequestRepository;

    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
        http
            // JWT를 사용하므로 세션 생성 정책을 STATELESS로 설정
            .sessionManagement(session -> session.sessionCreationPolicy(SessionCreationPolicy.STATELESS))
            
            .oauth2Login(oauth2 -> oauth2
                .authorizationEndpoint(authorization -> authorization
                    // 기본 로그인 진입점 설정
                    .baseUri("/oauth2/authorization")
                    // ★ 세션 대신 커스텀 쿠키 Repository 사용하도록 설정 ★
                    .authorizationRequestRepository(cookieAuthorizationRequestRepository)
                )
                // ... (성공 핸들러 등 나머지 설정)
            );

        return http.build();
    }
}
```


