# `OAuth2LoginAuthenticationFilter` 코드 레벨 분석 🔍🔐

(= “Authorization Server가 리다이렉트로 돌려준 **인가 코드(code)** 를 받아서 **인증을 시작**시키는 필터”)

`OAuth2LoginAuthenticationFilter`는 OAuth2/OIDC 로그인에서 **“콜백 엔드포인트(redirect URI)”** 를 처리하는 핵심 필터입니다. 🧩
즉, 사용자가 구글/네이버 등에서 로그인하고 돌아오면 브라우저는 보통 아래로 리다이렉트됩니다.

* `/login/oauth2/code/{registrationId}` ✅ (기본)

이 요청을 **딱 잡아서**,

* `code`, `state`를 꺼내고
* 기존에 저장해 둔 AuthorizationRequest와 매칭하고
* AuthenticationManager(Provider)로 넘겨서
* 최종적으로 `SecurityContext`에 로그인 세션을 심는 역할을 합니다. 🌱🔐

---

## 1) 필터의 “정체성”부터: 얘는 무슨 필터인가요? 🧠

`OAuth2LoginAuthenticationFilter`는 보통 다음 성격을 가집니다.

* `AbstractAuthenticationProcessingFilter` 계열 (요청 매칭 시 인증 시도)
* “로그인 콜백 전용” 처리기

📌 기본 매칭 URI

* `/login/oauth2/code/*`

---

## 2) 언제 등장하나요? (필터 체인 위치) 🧭

큰 흐름:

```text
[1] /oauth2/authorization/google
    → OAuth2AuthorizationRequestRedirectFilter (인가 요청 생성 & 저장 & 리다이렉트)

[2] (사용자 로그인/동의 후)
    Authorization Server → redirect_uri 로 리다이렉트
    /login/oauth2/code/google?code=...&state=...

[3] 여기서!
    → OAuth2LoginAuthenticationFilter  ⭐
        └─ AuthenticationManager → OAuth2LoginAuthenticationProvider
```

즉, 앞 단계 필터가 “밖으로 보내는 역할”이면
이 필터는 “돌아온 결과를 받아 인증을 완성시키는 역할”입니다. ✅

---

## 3) 이 필터가 하는 일: 한 문장 요약 ✍️

> “콜백 요청에서 `code/state`를 추출하고, 저장된 AuthorizationRequest를 복원해 교차검증한 뒤, `OAuth2LoginAuthenticationToken`을 만들어 Provider로 넘긴다.” 🔥

---

## 4) 내부 동작: 코드 레벨 의사코드로 보기 🔍

아래는 실제 내부 로직을 이해하기 좋은 형태로 재구성한 의사코드입니다.

```java
Authentication attemptAuthentication(HttpServletRequest request, HttpServletResponse response) {

  // 1) 이 요청이 OAuth2 Authorization Response(콜백)인지 확인
  if (!isAuthorizationResponse(request)) {
     throw new OAuth2AuthenticationException("invalid_request");
  }

  // 2) authorizationResponse 추출 (code, state, error 등)
  OAuth2AuthorizationResponse authorizationResponse =
      OAuth2AuthorizationResponseUtils.convert(request);

  // 3) 이전 단계에서 저장해둔 AuthorizationRequest를 복원/제거
  OAuth2AuthorizationRequest authorizationRequest =
      this.authorizationRequestRepository.removeAuthorizationRequest(request, response);

  if (authorizationRequest == null) {
     throw new OAuth2AuthenticationException("authorization_request_not_found");
  }

  // 4) state 검증 (CSRF 성격) ⭐
  if (!Objects.equals(authorizationResponse.getState(), authorizationRequest.getState())) {
     throw new OAuth2AuthenticationException("invalid_state");
  }

  // 5) registrationId 추출 (기본은 URI에서 추출: /login/oauth2/code/{registrationId})
  String registrationId = resolveRegistrationId(request);

  // 6) ClientRegistration 조회
  ClientRegistration clientRegistration =
      this.clientRegistrationRepository.findByRegistrationId(registrationId);

  if (clientRegistration == null) {
     throw new OAuth2AuthenticationException("client_registration_not_found");
  }

  // 7) AuthorizationExchange 구성 (요청+응답 묶음)
  OAuth2AuthorizationExchange exchange =
      new OAuth2AuthorizationExchange(authorizationRequest, authorizationResponse);

  // 8) AuthenticationToken(미인증 상태) 생성
  OAuth2LoginAuthenticationToken authRequest =
      new OAuth2LoginAuthenticationToken(clientRegistration, exchange);

  // 9) 세부정보 세팅 (IP, 세션 등)
  authRequest.setDetails(authenticationDetailsSource.buildDetails(request));

  // 10) AuthenticationManager로 위임 → Provider가 토큰 교환/유저로딩 수행
  Authentication authResult =
      this.getAuthenticationManager().authenticate(authRequest);

  // 11) 성공 시 AuthorizedClient 저장 (access_token/refresh_token 보관) ⭐
  OAuth2AuthenticationToken oauth2Auth =
      new OAuth2AuthenticationToken(authResult.getPrincipal(), authResult.getAuthorities(), registrationId);

  OAuth2AuthorizedClient authorizedClient =
      new OAuth2AuthorizedClient(clientRegistration,
                                 oauth2Auth.getName(),
                                 ((OAuth2LoginAuthenticationToken) authResult).getAccessToken(),
                                 ((OAuth2LoginAuthenticationToken) authResult).getRefreshToken());

  this.authorizedClientRepository.saveAuthorizedClient(authorizedClient, oauth2Auth, request, response);

  // 12) 최종 Authentication 반환 (SecurityContext에 들어갈 토큰)
  return oauth2Auth;
}
```

> ✅ 포인트:
> 이 필터는 “토큰 교환”을 **직접** 하지 않습니다.
> 토큰 교환은 Provider(`OAuth2LoginAuthenticationProvider`)가 합니다. 🎫
> 필터는 “콜백 → 인증 파이프라인 개시 + 결과 저장”에 집중합니다. 🧩

---

## 5) 핵심 구성요소 3개 (이거 모르면 디버깅 지옥) 😵‍💫

### ① `AuthorizationRequestRepository` 🗃️

* 이전 단계(`OAuth2AuthorizationRequestRedirectFilter`)가 저장한
  `OAuth2AuthorizationRequest`를 꺼내는 저장소
* 기본 구현은 보통 **HttpSession 기반**입니다.

여기에는:

* state
* redirect_uri
* scope
* authorization_uri
* client_id
* (PKCE면) code_challenge 관련 값
  등이 들어있습니다.

✅ 이걸 꺼내서 **state 검증**과 **exchange 구성**을 합니다.

---

### ② `ClientRegistrationRepository` 📒

* `registrationId`로 클라이언트 설정을 가져옵니다.
* application.yml의 `spring.security.oauth2.client.registration.*` 설정의 결과물

---

### ③ `OAuth2AuthorizedClientRepository` (또는 Service) 💾

* 토큰 교환이 끝난 뒤 발급된:

  * access_token
  * refresh_token
    을 “어딘가”에 저장해서
    나중에 API 호출(WebClient/RestTemplate)할 때 재사용하도록 합니다.

기본 저장 위치는 환경에 따라:

* Session
* SecurityContext
* 또는 커스텀 저장소

---

## 6) 이 필터의 “성공/실패” 시나리오 🎯

### ✅ 성공하면

* `OAuth2AuthenticationToken`이 SecurityContext로 들어갑니다 🔐
* `OAuth2AuthorizedClient`가 저장됩니다 💾
* 다음 요청부터 `@AuthenticationPrincipal`로 사용자 접근 가능 👤

### ❌ 실패하면

주로 아래에서 터집니다:

* `authorization_request_not_found`

  * 세션 만료 / 다른 브라우저 / 서버 재시작 등
* `invalid_state`

  * CSRF 방어 실패 (state 불일치)
* Provider 쪽 예외

  * code 만료, redirect_uri 불일치, client 인증 실패 등

---

## 7) 실무 디버깅 체크리스트 TOP 7 🧯

1. **콜백 URI가 Security FilterChain에서 permitAll 되어 있는지**

   * `/login/oauth2/code/**` 막혀 있으면 아예 못 들어옵니다.

2. **세션이 유지되는지**

   * AuthorizationRequestRepository가 세션 기반이면
     로그인 전후로 세션이 끊기면 `authorization_request_not_found` 💥

3. **SameSite 쿠키 정책**

   * 크로스 사이트 리다이렉트에서 쿠키가 안 붙을 수 있음 (특히 최신 브라우저) 🍪

4. **state 불일치**

   * 프록시/로드밸런서에서 리다이렉트가 꼬이거나
     여러 탭에서 로그인 동시에 시도하면 종종 발생

5. **registrationId 매칭**

   * `/login/oauth2/code/google`인데 설정은 `google2`로 되어 있으면 실패

6. **redirect_uri 템플릿**

   * `{baseUrl}` 계산이 프록시 환경에서 잘못되면 token 교환에서 실패

7. **AuthorizedClient 저장소**

   * 저장이 안 되면 이후 API 호출에서 토큰을 못 찾습니다.

---

## 8) 한 줄 요약 🧾✨

`OAuth2LoginAuthenticationFilter`는

✅ Authorization Server가 돌려준 콜백 요청(`/login/oauth2/code/{registrationId}`)에서
✅ `code/state`를 뽑고
✅ 저장해둔 AuthorizationRequest와 **state 검증**을 하고
✅ `OAuth2LoginAuthenticationProvider`로 인증을 위임한 다음
✅ 결과로 발급된 토큰을 `OAuth2AuthorizedClientRepository`에 저장하고
✅ 최종 `OAuth2AuthenticationToken`을 SecurityContext에 넣는 “콜백 처리 필터”입니다. 🔥🔐

---

### 참고 사항
* 🔥 `AuthorizationRequestRepository`가 세션에서 어떤 키로 저장되는지, 멀티서버 환경에서 깨지는 이유
* 🔥 프록시/게이트웨이 환경에서 `{baseUrl}`/redirect_uri 깨짐 해결 패턴 (ForwardedHeaderFilter 포함)
