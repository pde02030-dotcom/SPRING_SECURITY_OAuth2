# OAuth 2.0 `scope` 🧩🔐

OAuth 2.0을 제대로 이해하려면 “토큰(access token)은 **무엇을 할 수 있는 권한**을 담고 있나?”를 봐야 합니다.
그 **권한의 범위**를 표현하는 핵심 키워드가 바로 `scope`입니다. 🎯

---

## 1) scope란 무엇인가? 🎫➡️🛡️

### ✅ 한 줄 정의

`scope`는 **클라이언트가 액세스 토큰으로 접근할 수 있는 리소스/행동 범위를 제한하는 “권한의 단위”** 입니다.

즉,

* access token을 발급받았다고 해서 “모든 API”를 호출할 수 있는 게 아니라
* 토큰이 허용한 범위(scope) 안에서만 호출 가능하도록 **최소 권한(Least Privilege)** 을 구현합니다. 🧠✅

---

## 2) scope는 누가 정하나? (클라이언트? 서버? 사용자?) 🤝

OAuth 2.0의 설계는 “클라이언트가 요청”하고 “서버가 승인/거절/축소”하는 구조입니다.

### 🎛️ 결정 주체 3명

* **Client(클라이언트)**: “저는 `read`랑 `write`가 필요해요!”라고 요청 🧑‍💻
* **Authorization Server(권한 서버)**: 요청을 검증하고 “승인 가능한 scope만” 발급 🏛️
* **Resource Owner(사용자)** (Authorization Code 플로우): 동의 화면에서 승인 👤✅

📌 특히 Authorization Server는 scope를 **그대로 주지 않아도 됩니다.**
요청한 scope를 **줄여서(narrow)** 발급하는 것도 정상 동작입니다. ✂️

---

## 3) scope의 기본 형태와 문법 🧱

### ✅ 가장 흔한 표현

OAuth 2.0에서는 scope를 보통 **공백으로 구분된 문자열**로 표현합니다.

예:

```
scope=read write
```

또는 URL 인코딩되면:

```
scope=read%20write
```

### ✅ 토큰 응답에 포함되는 scope

권한 서버가 발급한 실제 scope는 토큰 응답에 들어갈 수 있습니다.

예(개념):

```json
{
  "access_token": "....",
  "token_type": "Bearer",
  "expires_in": 3600,
  "scope": "read"
}
```

➡️ 이 경우, 클라이언트는 `read write`를 원했지만 서버가 `read`만 준 것입니다. ✂️🛡️

---

## 4) scope는 왜 필요한가? (보안/운영 관점) 🧠🔒

scope가 없거나, 너무 넓으면 어떤 일이 생길까요?

### ❌ scope가 너무 넓은 토큰 = 사고 확률 폭증 💥

* 토큰이 유출되면 공격자가 **모든 API를 호출**
* 내부 시스템이 마치 “마스터 키”처럼 뚫림

### ✅ scope를 잘 쪼개면

* 토큰이 유출되어도 피해 범위를 제한 🧯
* 특정 기능만 허용하는 “목적성 토큰” 발급 가능 🎯
* 권한/요금제/테넌트 정책을 scope로 설계 가능 🏢

---

## 5) scope는 “권한”인가? “역할(Role)”인가? 🆚

여기서 실무에서 정말 많이 혼동합니다. 😵‍💫

### ✅ scope vs role 차이

* **scope**: “이 토큰이 허용하는 API 접근 범위(행위 단위)” 🎫
* **role(권한/역할)**: “사용자/주체의 조직적 권한(정체성 기반)” 👤

예시로 비유하면:

* scope: “문서 읽기(read) / 문서 쓰기(write)” 📝
* role: “관리자(admin) / 일반유저(user)” 👔

📌 실무에서는 둘을 같이 쓰기도 합니다.

* `ROLE_ADMIN` 사용자라도 토큰이 `read`만 있으면 `write` API는 차단할 수 있음 ✅

---

## 6) Authorization Code 플로우에서 scope가 어떻게 쓰이나? 🔁

사용자가 구글 로그인(Authorization Code)을 한다고 하면:

1. 클라이언트가 authorization endpoint로 보냄

   * `scope=profile email`
2. 구글이 동의 화면에서 “프로필/이메일 접근 허용할까요?” 표시 📜✅
3. 사용자가 승인하면 access token 발급
4. access token에 `profile email` scope가 반영

즉, scope는 **동의 화면(Consent)** 과 직결됩니다. 🧾👀

---

## 7) Client Credentials 플로우에서 scope는 어떻게 되나? 🤖🔑

Client Credentials는 “사용자 없음”이 핵심입니다.

* 사용자 동의가 없고
* 클라이언트 자체 권한으로 토큰 발급

따라서 scope는 보통:

* “클라이언트에 허용된 scope 목록” 내에서만 발급됩니다. 🏛️

예:

* order-service가 payment-service의 결제 생성 API를 호출해야 한다
* 그러면 `payments:write` 같은 scope를 등록해두고
* 해당 클라이언트 자격증명으로 발급되는 토큰에 그 scope만 부여

👉 마이크로서비스 간 통신에서 scope 설계가 특히 중요합니다. 🧩🌐

---

## 8) scope 설계 방법(실무 패턴) 🏗️

scope는 표준이 강제하는 “정해진 이름”이 없습니다(일부 표준 scope 제외).
즉, 설계가 곧 아키텍처입니다. 🧠

### ✅ 패턴 A: CRUD 기반

* `read`, `write`, `delete`
* 장점: 단순
* 단점: 리소스별 세분화 어려움

### ✅ 패턴 B: 리소스 기반(권장)

* `users:read`, `users:write`
* `orders:read`, `orders:write`
* `payments:refund`
* 장점: API 도메인에 맞게 세분화 좋음 👍

### ✅ 패턴 C: 액션 기반(업무 행위 중심)

* `invoice:issue`
* `shipment:create`
* `report:export`
* 장점: 비즈니스 권한과 자연스럽게 매핑됨 🧾🚚

### ✅ 패턴 D: 테넌트/환경/등급 결합(주의)

* `tenant:123:orders:read`
* `plan:pro:report:export`
* 장점: 강력
* 단점: 토큰/정책 복잡도 급증 😵 (정말 필요한 경우만)

---

## 9) scope는 토큰(JWT) 안에 어떻게 들어가나? 🪙

JWT access token을 쓰는 경우(권한 서버가 JWT로 발급):

대표적으로 scope는 다음 중 하나로 들어갑니다.

* `scope`: `"read write"` (문자열)
* `scp`: `["read", "write"]` (배열)
* `authorities`: `["SCOPE_read", "SCOPE_write"]` (스프링 권한 스타일)

📌 어떤 클레임을 쓰는지는 **권한 서버 구현에 따라 다릅니다.**
그래서 Resource Server에서 “어느 클레임을 scope로 볼지” 매핑이 중요합니다. 🧩

---

## 10) Spring Security Resource Server에서 scope는 어떻게 권한이 되나? 🛡️🌱

Spring Security는 scope를 보통 `GrantedAuthority`로 변환해서 다룹니다.

### ✅ 기본 관례: `SCOPE_` 접두사

* scope `read` → authority `SCOPE_read`
* scope `orders:write` → authority `SCOPE_orders:write`

그래서 보통 이렇게 보호합니다:

```java
http.authorizeHttpRequests(auth -> auth
    .requestMatchers("/orders/**").hasAuthority("SCOPE_orders:read")
    .requestMatchers(HttpMethod.POST, "/orders/**").hasAuthority("SCOPE_orders:write")
    .anyRequest().authenticated()
);
```

또는 메서드 보안:

```java
@PreAuthorize("hasAuthority('SCOPE_orders:write')")
public void createOrder(...) { ... }
```

📌 여기서 핵심:
**Spring Security 입장에서 scope는 “권한(Authority)”로 취급됩니다.** ✅

---

## 11) scope와 OpenID Connect의 관계 🪪✨

OIDC를 쓰면 `scope`에 특별한 것들이 등장합니다.

### ✅ OIDC 필수 scope: `openid`

* `openid`가 있어야 “이건 OAuth2 로그인 + 사용자 인증(OIDC)”로 인식됩니다.

### ✅ 자주 쓰는 OIDC scope

* `profile`: 이름/사진 등 프로필 정보
* `email`: 이메일
* `address`
* `phone`

예:

```
scope=openid profile email
```

📌 실무 포인트:

* 단순 API 권한(scope)과
* “사용자 정보 클레임을 달라”(OIDC scope)
  가 한 요청에 섞여 있을 수 있습니다. 🧩

---

## 12) scope 관련 보안 이슈 & 실수 TOP 8 ⚠️💥

1. **scope를 너무 넓게 한 번에 다 요청**
   → 토큰 유출 시 피해 확대 💣

2. **권한 서버가 requested scope를 그대로 발급한다고 가정**
   → 실제로는 축소될 수 있음(반드시 응답 scope 확인) ✂️

3. **scope를 role처럼 사용**
   → 유지보수 지옥(조직 권한과 API 권한이 섞임) 😵

4. **사내 API인데 scope 없이 내부망만 믿음**
   → 내부망 침해 시 “올-오픈” 💥

5. **scope 네이밍이 일관되지 않음**
   → orders:read, order.read, ORDER_READ 혼재 🤯

6. **테넌트/환경을 scope 문자열로 과도하게 인코딩**
   → 정책/감사/회수 어려움 🧨

7. **refresh token으로 scope 확장 시도**
   → 보통 refresh는 확장(X), 재승인 필요(서버 정책) 🧾

8. **Resource Server에서 scope→authority 매핑 미스**
   → 보호가 안 되거나 과도하게 막힘 🧱

---

## 13) scope 설계 체크리스트 ✅🧭

* [ ] 최소 권한 원칙: 기능별로 scope가 너무 뭉쳐있지 않은가? 🎯
* [ ] 리소스 기반/행위 기반 중 하나로 통일했는가? 🧱
* [ ] API 라우팅과 scope가 자연스럽게 매핑되는가? 🛣️
* [ ] 관리자(Role)와 API 접근(scope)을 분리했는가? 🧑‍💼🆚🎫
* [ ] 마이크로서비스 간 통신에 필요한 scope만 발급되는가? 🤖
* [ ] 토큰 클레임에서 scope가 어디에 들어가는지 명확한가? 🪙
* [ ] Spring Security에서 `SCOPE_` 권한으로 검증되는가? 🛡️

---

## 14) 결론 ✍️✅

`scope`는 OAuth 2.0에서

* 🎫 “토큰이 할 수 있는 일”을 정의하고
* 🔐 권한을 최소화하며
* 🧩 리소스 서버의 접근 제어와 직접 연결되는

**가장 중요한 보안 설계 단위**입니다.


