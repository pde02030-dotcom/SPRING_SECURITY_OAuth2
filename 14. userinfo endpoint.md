# 🧭 UserInfo Endpoint (OAuth2 / OIDC) — “로그인한 사용자는 **누구**인가?”

OAuth2 로그인 흐름에서 **Authorization Code → Access Token**까지 받았다고 끝이 아닙니다.
이제 “이 토큰의 주인은 누구지?”를 알아내야 하고, 그때 등장하는 게 바로 **UserInfo Endpoint** 입니다. 😎

---

## 1) 🧩 UserInfo Endpoint란?

**UserInfo Endpoint**는 “발급된 Access Token을 들고 가면, 그 토큰이 대표하는 사용자(리소스 오너)의 프로필 정보를 JSON으로 돌려주는 HTTP API”입니다. ✅

* OAuth2 관점: **Protected Resource API** 중 하나(표준화된 프로필 API 느낌)
* OIDC(OpenID Connect) 관점: **표준 스펙으로 정의된 endpoint**

  * `/userinfo` 는 OIDC에서 매우 핵심 구성요소입니다 🧠

즉, UserInfo Endpoint는 **“사용자 식별 + 프로필 클레임 조회”**를 담당합니다. 👤📦

---

## 2) 🔄 언제 호출될까? (로그인 플로우에서의 위치)

Spring Security OAuth2 Login 흐름을 기준으로 보면:

1. 🧾 Authorization Code 획득
2. 🎟️ Code로 Access Token 발급
3. 👤 **UserInfo Endpoint 호출** (Access Token으로)
4. 🧑‍💻 응답(JSON)을 `OAuth2User`(또는 `OidcUser`)로 매핑
5. 🔐 SecurityContext에 Authentication 저장

여기서 3번이 바로 **UserInfo Endpoint 호출**입니다. 🚀

---

## 3) 🎯 왜 굳이 UserInfo를 호출해야 하나?

### ✅ 이유 A: Access Token만으로는 “사용자 정보”가 없음

Access Token은 “권한”을 나타내는 토큰이지, 항상 사용자 프로필을 담지 않습니다.
그래서 **별도 API로 사용자 정보를 조회**하는 패턴이 표준처럼 굳었습니다. 🧾➡️👤

### ✅ 이유 B: ID Token이 없거나(순수 OAuth2), 부족한 경우

* **OIDC 로그인**이면 보통 **ID Token**을 함께 받습니다 🪪

  * ID Token에는 `sub`, `email` 등 많은 정보가 들어올 수 있음
* 그래도 다음 상황에선 UserInfo가 유용합니다:

  * ID Token에 원하는 클레임이 빠짐 😢
  * “최신 프로필”이 필요함(사용자가 프로필 변경) 🔄
  * 공급자가 UserInfo를 강하게 권장/기본 제공 📌

### ✅ 이유 C: 표준화된 “사용자 클레임 조회” 방식(OIDC)

OIDC는 “로그인”을 **표준화된 사용자 식별 방식**으로 만들고 싶었습니다.
그래서 UserInfo를 명세로 박아둔 거죠. 📚✨

---

## 4) 📦 UserInfo 응답 데이터(클레임)의 성격

UserInfo 응답은 보통 이런 느낌입니다:

```json
{
  "sub": "103948203948203948",
  "name": "Seongwon Seo",
  "email": "seongwon@example.com",
  "picture": "https://...",
  "email_verified": true
}
```

여기서 핵심은:

* `sub` (Subject) 🔑

  * **해당 공급자 내에서 유일한 사용자 ID**
  * 사실상 “로그인 식별자”의 뼈대
* 나머지는 프로필(선택적) 🎭

  * `name`, `email`, `picture`, `locale` 등

---

## 5) 🔐 호출 방식: Authorization 헤더가 핵심!

UserInfo 호출은 거의 항상 다음 형태입니다:

* HTTP Method: `GET` (가끔 `POST`도 있음)
* 인증: `Authorization: Bearer <access_token>` 🎟️

```http
GET /userinfo
Authorization: Bearer ya29.a0AfH6S...
```

즉, UserInfo Endpoint는 **리소스 서버**처럼 동작합니다. 🛡️
(토큰 검증 → 클레임 조회 → JSON 반환)

---

## 6) 🏗️ Spring Security에서 UserInfo는 누가 호출하나?

Spring Security OAuth2 Login에서 UserInfo 호출 담당은 보통 다음 구조입니다. 🧱

### ✅ OAuth2 로그인(일반 OAuth2 Provider)

* `OAuth2LoginAuthenticationFilter` → Provider → `OAuth2UserService`
* 기본 구현체: **`DefaultOAuth2UserService`** 📌

  * 내부에서 `RestTemplate`/`WebClient`로 UserInfo 호출
  * JSON을 `Map<String, Object>`로 받아서 `DefaultOAuth2User` 생성

### ✅ OIDC 로그인(OpenID Provider)

* 기본 구현체: **`OidcUserService`** 🪪

  * 기본적으로 ID Token 기반 매핑이 가능
  * 설정/상황에 따라 UserInfo도 호출해서 클레임을 합칠 수 있음

---

## 7) 🧠 “userNameAttributeName”이 진짜 중요합니다 (식별자 선택)

Spring Security는 UserInfo 응답에서 “이 사용자를 대표하는 키가 뭐냐?”를 알아야 합니다.
그게 바로 **`userNameAttributeName`** 입니다. 🏷️

* 대부분 OIDC는 `sub`를 씁니다 ✅
* 어떤 OAuth2 Provider는 `id`, `user_id`, `login` 같은 키를 씁니다

설정 예시(개념):

* “UserInfo 응답에서 `id`를 principal name으로 쓰겠다”
  → `userNameAttributeName = "id"`

이게 왜 중요하냐면:

* 인증 후 `Authentication.getName()` 값이 이걸 기반으로 잡힙니다 🔐
* DB에 사용자 매핑할 때 “고유키”로 쓰는 경우가 많습니다 🗄️

---

## 8) ⚠️ UserInfo Endpoint에서 자주 터지는 문제들

### 🚨 문제 1: scope 부족 → 403/insufficient_scope

UserInfo는 보통 특정 scope가 있어야 정보가 옵니다.

* OIDC면 `openid`는 거의 필수 🪪
* `email`, `profile` 같은 scope가 있어야 해당 필드가 나옵니다 📧👤

✅ 해결:

* Client 등록 시 scope를 추가하세요 (`scope: openid, profile, email`)

---

### 🚨 문제 2: UserInfo 응답에 식별자 키가 없다

`userNameAttributeName`으로 설정한 키가 UserInfo 응답에 없으면 매핑 실패 가능성이 큽니다 😵

✅ 해결:

* 실제 UserInfo 응답 JSON을 확인해서 키를 맞추세요
* OIDC면 `sub`가 가장 안전합니다 🔑

---

### 🚨 문제 3: “Access Token은 받았는데 UserInfo가 401”

대개 이런 케이스입니다:

* 토큰이 UserInfo 리소스에 유효하지 않음(잘못된 audience 등) 🎯
* provider가 UserInfo에 특정 방식(POST, 특정 헤더)을 요구함 🧩
* 토큰이 만료/취소됨 ⏳

✅ 해결:

* provider 문서대로 호출 조건 확인
* 토큰 클레임(aud, scope 등) 점검

---

## 9) 🛠️ 실전 커스터마이징: UserInfo 응답을 “내 도메인”으로 매핑하기

실무에서는 보통 UserInfo 응답을 그대로 쓰지 않고, 아래처럼 변환합니다. 🔧

* 공급자마다 필드명이 다름(google: `sub`, github: `id`, naver/kakao 등 제각각) 🤹
* 우리 시스템의 `User` 엔티티 구조에 맞춰야 함 🗄️

### ✅ 커스텀 `OAuth2UserService` 패턴

```java
@Bean
public SecurityFilterChain security(HttpSecurity http) throws Exception {
    http
      .oauth2Login(oauth -> oauth
        .userInfoEndpoint(userInfo -> userInfo
          .userService(customOAuth2UserService())
        )
      );
    return http.build();
}
```

커스텀 서비스에서 하는 일(핵심):

* 기본 서비스로 UserInfo를 먼저 받아오고 📥
* provider별로 attribute 정규화(normalize) 하고 🧼
* DB에 upsert(가입/갱신) 후 🗄️
* 최종 principal을 우리가 원하는 형태로 반환 🎁

---

## 10) 🔒 보안 관점에서의 체크포인트

### ✅ (1) UserInfo는 “토큰 기반 API”라서 공격면이 있다 🛡️

* 토큰 탈취 시 UserInfo 호출로 개인정보가 노출될 수 있음 😬
* 따라서 HTTPS는 필수, 토큰 저장도 엄격히 해야 합니다 🔐

### ✅ (2) UserInfo 응답을 “신뢰할 수 있는 출처”로만 다룰 것

* 공급자 서버에서 온 응답이라도, 우리 시스템에서 **권한(roles)**까지 믿으면 위험합니다 ⚠️
* 보통은:

  * UserInfo는 “신원 식별 + 프로필”까지만 사용 👤
  * 권한은 **우리 DB/내부 정책**으로 결정 👮

### ✅ (3) OIDC라면 ID Token 검증이 기본

OIDC에서는 UserInfo도 중요하지만, **ID Token 서명 검증(JWK 기반)**이 훨씬 핵심 보안 축입니다 🪪✅

---

## 11) 🧭 정리: UserInfo Endpoint를 한 문장으로

✅ **UserInfo Endpoint는 Access Token을 근거로 “이 토큰의 사용자(주체)가 누구인지”와 “프로필 클레임”을 표준 방식으로 제공하는 API**입니다. 👤🎟️📦


